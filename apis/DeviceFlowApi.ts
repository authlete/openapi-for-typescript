// tslint:disable
/**
 * Authlete API
 * Authlete API Document. 
 *
 * The version of the OpenAPI document: 2.2.30
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import type { Observable } from 'rxjs';
import type { AjaxResponse } from 'rxjs/ajax';
import { BaseAPI, throwIfNullOrUndefined } from '../runtime';
import type { OperationOpts, HttpHeaders } from '../runtime';
import type {
    DeviceAuthorizationRequest,
    DeviceAuthorizationResponse,
    DeviceCompleteRequest,
    DeviceCompleteResponse,
    DeviceVerificationRequest,
    DeviceVerificationResponse,
    Result,
} from '../models';

export interface DeviceAuthorizationApiRequest {
    deviceAuthorizationRequest: DeviceAuthorizationRequest;
}

export interface DeviceCompleteApiRequest {
    deviceCompleteRequest: DeviceCompleteRequest;
}

export interface DeviceVerificationApiRequest {
    deviceVerificationRequest: DeviceVerificationRequest;
}

/**
 * no description
 */
export class DeviceFlowApi extends BaseAPI {

    /**
     * This API parses request parameters of a [device authorization request](https://datatracker.ietf.org/doc/html/rfc8628#section-3.1) and returns necessary data for the authorization server implementation to process the device authorization request further.  <br> <details> <summary>Description</summary>  This API is supposed to be called from the within the implementation of the device authorization endpoint of the service. The service implementation should retrieve the value of `action` from the response and take the following steps according to the value.  **INTERNAL_SERVER_ERROR**  When the value of `action` is `INTERNAL_SERVER_ERROR`, it means that the API call from the authorization server implementation was wrong or that an error occurred in Authlete.  In either case, from a viewpoint of the client application, it is an error on the server side. Therefore, the authorization server implementation should generate a response to the client application with \"500 Internal Server Error\"s and `application/json`.  The value of `responseContent` is a JSON string which describes t he error, so it can be used as the entity body of the response.  The following illustrates the response which the authorization server implementation should generate and return to the client application.  ``` HTTP/1.1 500 Internal Server Error Content-Type: application/json Cache-Control: no-store Pragma: no-cache  {responseContent} ```  **BAD_REQUEST**  When the value of `action` is `BAD_REQUEST`, it means that the request from the client application is wrong.  The authorization server implementation should generate a response to the client application with \"400 Bad Request\" and `application/json`.  The value of `responseContent` is a JSON string which describes the error, so it can be used as the entity body of the response.  The following illustrates the response which the service implementation should generate and return to the client application.  ``` HTTP/1.1 400 Bad Request Content-Type: application/json Cache-Control: no-store Pragma: no-cache  {responseContent} ```  **UNAUTHORIZED**  When the value of `action` is `UNAUTHORIZED`, it means that client authentication of the device authorization request failed.  The authorization server implementation should generate a response to the client application with \"401 Unauthorized\" and `application/json`.  The value of `responseContent` is a JSON string which describes the error, so it can be used as the entity body of the response.  The following illustrates the response which the service implementation must generate and return to the client application.  ``` HTTP/1.1 401 Unauthorized WWW-Authenticate: (challenge) Content-Type: application/json Cache-Control: no-store Pragma: no-cache  {responseContent} ```  **OK**  When the value of `action` is `OK`, it means that the device authorization request from the client application is valid.  The authorization server implementation should generate a response to the client application with \"200 OK\" and `application/json`.  The `responseContent` is a JSON string which can be used as the entity body of the response.  The following illustrates the response which the authorization server implementation should generate and return to the client application. </details> 
     * /api/device/authorization API
     */
    deviceAuthorizationApi({ deviceAuthorizationRequest }: DeviceAuthorizationApiRequest): Observable<DeviceAuthorizationResponse>
    deviceAuthorizationApi({ deviceAuthorizationRequest }: DeviceAuthorizationApiRequest, opts?: OperationOpts): Observable<AjaxResponse<DeviceAuthorizationResponse>>
    deviceAuthorizationApi({ deviceAuthorizationRequest }: DeviceAuthorizationApiRequest, opts?: OperationOpts): Observable<DeviceAuthorizationResponse | AjaxResponse<DeviceAuthorizationResponse>> {
        throwIfNullOrUndefined(deviceAuthorizationRequest, 'deviceAuthorizationRequest', 'deviceAuthorizationApi');

        const headers: HttpHeaders = {
            'Content-Type': 'application/json',
            ...(this.configuration.username != null && this.configuration.password != null ? { Authorization: `Basic ${btoa(this.configuration.username + ':' + this.configuration.password)}` } : undefined),
        };

        return this.request<DeviceAuthorizationResponse>({
            url: '/api/device/authorization',
            method: 'POST',
            headers,
            body: deviceAuthorizationRequest,
        }, opts?.responseOpts);
    };

    /**
     * This API returns information about what action the authorization server should take after it receives the result of end-user\'s decision about whether the end-user has approved or rejected a client application\'s request.  <br> <details> <summary>Description</summary>  In the device flow, an end-user accesses the verification endpoint of the authorization server where she interacts with the verification endpoint and inputs a user code. The verification endpoint checks if the user code is valid and then asks the end-user whether she approves or rejects the authorization request which the user code represents.  After the authorization server receives the decision of the end-user, it should call Authlete\'s `/device/complete` API to tell Authlete the decision.  When the end-user was authenticated and authorization was granted to the client by the end-user, the authorization server should call the API with `result=AUTHORIZED`. In this successful case, the subject request parameter is mandatory. The API will update the database record so that `/auth/token` API can generate an access token later.  If the `scope` parameter of the device authorization request included the openid scope, an ID token is generated. In this case, `sub`, `authTime`, `acr` and `claims` request parameters in the API call to `/device/complete` affect the ID token.  When the authorization server receives the decision of the end-user and it indicates that she has rejected to give authorization to the client, the authorization server should call the API with `result=ACCESS_DENIED`. In this case, the API will update the database record so that the `/auth/token` API can generate an error response later. If `errorDescription` and `errorUri` request parameters are given to the `/device/complete` API, they will be used as the values of `error_description` and `error_uri` response parameters in the error response from the token endpoint.  When the authorization server could not get decision from the end-user for some reasons, the authorization server should call the API with `result=TRANSACTION_FAILED`. In this error case, the API will behave in the same way as in the case of `ACCESS_DENIED`. The only difference is that `expired_token` is used as the value of the `error` response parameter instead of `access_denied`.  After receiving a response from the `/device/complete` API, the implementation of the authorization server should retrieve the value of `action` from the response and take the following steps according to the value.  **SERVER_ERROR**  When the value of `action` is `SERVER_ERROR`, it means that an error occurred on Authlete side. The authorization server implementation should tell the end-user that something wrong happened and urge her to re-initiate a device flow.  **USER_CODE_NOT_EXIST**  When the value of `action` is `USER_CODE_NOT_EXIST`, it means that the user code included in the API call does not exist. The authorization server implementation should tell the end-user that the user code has been invalidated and urge her to re-initiate a device flow.  **USER_CODE_EXPIRED**  When the value of `action` is `USER_CODE_EXPIRED`,  it means that the user code included in the API call has expired. The authorization server implementation should tell the end-user that the user code has expired and urge her to re-initiate a device flow.  **INVALID_REQUEST**  When the value of `action` is `INVALID_REQUEST`, it means that the API call is invalid. Probably, the authorization server implementation has some bugs.  **SUCCESS**  When the value of `action` is `SUCCESS`, it means that the API call has been processed successfully. The authorization server should return a successful response to the web browser the end-user is using. </details> 
     * /api/device/complete API
     */
    deviceCompleteApi({ deviceCompleteRequest }: DeviceCompleteApiRequest): Observable<DeviceCompleteResponse>
    deviceCompleteApi({ deviceCompleteRequest }: DeviceCompleteApiRequest, opts?: OperationOpts): Observable<AjaxResponse<DeviceCompleteResponse>>
    deviceCompleteApi({ deviceCompleteRequest }: DeviceCompleteApiRequest, opts?: OperationOpts): Observable<DeviceCompleteResponse | AjaxResponse<DeviceCompleteResponse>> {
        throwIfNullOrUndefined(deviceCompleteRequest, 'deviceCompleteRequest', 'deviceCompleteApi');

        const headers: HttpHeaders = {
            'Content-Type': 'application/json',
            ...(this.configuration.username != null && this.configuration.password != null ? { Authorization: `Basic ${btoa(this.configuration.username + ':' + this.configuration.password)}` } : undefined),
        };

        return this.request<DeviceCompleteResponse>({
            url: '/api/device/complete',
            method: 'POST',
            headers,
            body: deviceCompleteRequest,
        }, opts?.responseOpts);
    };

    /**
     * The API returns information associated with a user code.  <br> <details> <summary>Description</summary>  After receiving a response from the device authorization endpoint of the authorization server, the client application shows the end-user the user code and the verification URI which are included in the device authorization response. Then, the end-user will access the verification URI using a web browser on another device (typically, a smart phone). In normal implementations, the verification endpoint will return an HTML page with an input form where the end-user inputs a user code. The authorization server will receive a user code from the form.  After receiving a user code, the authorization server should call Authlete\'s `/device/verification` API with the user code. And then, the authorization server implementation should retrieve the value of `action` parameter from the API response and take the following steps according to the value.  **SERVER_ERROR**  When the value of `action` is `SERVER_ERROR`, it means that an error occurred on Authlete side. The authorization server implementation should tell the end-user that something wrong happened and urge her to re-initiate a device flow.  **NOT_EXIST**  When the value of `action` is `NOT_EXIST`, it means that the user code does not exist. The authorization server implementation should tell the end-user that the user code is invalid and urge her to retry to input a valid user code.  **EXPIRED**  When the value of `action` is `EXPIRED`, it means that the user code has expired. The authorization server implementation should tell the end-user that the user code has expired and urge her to re-initiate a device flow.  **VALID**  When the value of `action` is `VALID`, it means that the user code exists, has not expired, and belongs to the service. The authorization server implementation should interact with the end-user to ask whether she approves or rejects the authorization request from the device. </details> 
     * /api/device/verification API
     */
    deviceVerificationApi({ deviceVerificationRequest }: DeviceVerificationApiRequest): Observable<DeviceVerificationResponse>
    deviceVerificationApi({ deviceVerificationRequest }: DeviceVerificationApiRequest, opts?: OperationOpts): Observable<AjaxResponse<DeviceVerificationResponse>>
    deviceVerificationApi({ deviceVerificationRequest }: DeviceVerificationApiRequest, opts?: OperationOpts): Observable<DeviceVerificationResponse | AjaxResponse<DeviceVerificationResponse>> {
        throwIfNullOrUndefined(deviceVerificationRequest, 'deviceVerificationRequest', 'deviceVerificationApi');

        const headers: HttpHeaders = {
            'Content-Type': 'application/json',
            ...(this.configuration.username != null && this.configuration.password != null ? { Authorization: `Basic ${btoa(this.configuration.username + ':' + this.configuration.password)}` } : undefined),
        };

        return this.request<DeviceVerificationResponse>({
            url: '/api/device/verification',
            method: 'POST',
            headers,
            body: deviceVerificationRequest,
        }, opts?.responseOpts);
    };

}
